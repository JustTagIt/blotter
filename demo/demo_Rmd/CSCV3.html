<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Jasen Mackie" />

<meta name="date" content="2018-08-11" />

<title>A replication of the Practical Application section in The Probability of Backtest Overfitting - Bailey et al.</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">A replication of the Practical Application section in ‘The Probability of Backtest Overfitting’ - Bailey et al.</h1>
<h4 class="author"><em>Jasen Mackie</em></h4>
<h4 class="date"><em>2018-08-11</em></h4>



<p>In their paper “The Probability of Backtest Overfitting” [<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2326253" class="uri">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2326253</a>] Bailey et al. introduce a method for detecting overfitting. They refer to the method as CSCV or Combinatorially Symmetric Cross Validation. Bailey et al. proceed to show that CSCV produces reasonable estimates of PBO for several useful examples.</p>
<p>To illustrate the ease with which a random series can produce an overfit trading rule, Bailey et al. in “Pseudo-Mathematics and Financial Charlatanism: The Effects of Backtest Overfitting on Out-of-Sample Performance” [<a href="http://www.ams.org/notices/201405/rnoti-p458.pdf" class="uri">http://www.ams.org/notices/201405/rnoti-p458.pdf</a>] seek to identify an optimal <strong>monthly</strong> trading rule based on 4 parameters, namely: Entry day, Holding Period, Stop Loss and Side. Using the ranges C(1:22), c(1:20), c(0:10) and c(-1,1) respectively, their program iterates through each permutation (8800 in total) to determine the strategy with the highest Sharpe ratios (SR). Their example produces an optimal SR of 1.27. The authors extend the data mining example by applying a seasonal adjustment to the first 5 days of each month. Particularly, they scale the daily returns by a factor of a quarter of the sigma used to generate the original series. The python program for replicating this data mining process can be found here [<a href="http://www.quantresearch.info/CSCV_3.py.txt" class="uri">http://www.quantresearch.info/CSCV_3.py.txt</a>]. Using their CSCV method for computing the PBO of each series of trials the authors are able to illustrate examples of how CSCV diagnoses the probability of backtest overfitting for an overfit random strategy versus a strategy with a legitimate seasonal component.</p>
<p>The below code and analysis is an R-ported version of the python program together with some PBO output derived using the new <em>blotter:::pbo</em> function for the purposes of replicating the paper introducing the CSCV method.</p>
<p>The main function is the dataMine() function, called backTest() in the original python program. We store the output as an S3 object, making possible the extension of additional analysis on the pbo output. There are a number of helper functions, namely:</p>
<ul>
<li>numBusinessDays - for assigning an integer to the respective date, representing which business day in the month it is. This is used when applying the seasonality adjustement to the first ‘nDays’ of each month. Applicable when param ‘nDays’ is greater than 0.</li>
<li>getRefDates_MonthBusinessDate - for determining the respective nth business day in each month. Each month will have a 1st business day, so we assign dates for each 1st business day, then again for each 2nd business day of each month, etc.</li>
<li>getTrades - taking into consideration the constraints of the strategy (entry day, holding period {param name ‘exit’}, stop loss and side), this function returns the trades.</li>
<li>attachTimeSeries - we keep a record of the daily returns for each trial (8800 in the paper) which we apply to the pbo() function. This function attaches each iterated trial.</li>
<li>evalPerf - used for recording various metrics for computing the psrStat as well as the Sharpe ratio, which is the performance metric used in the paper. Bailey et al. emphasise that other metrics can be used with their framework (eg. Sortino ratio, Jensen’s Alpha, Probabilistic Sharpe Ratio, etc), and introducing a range of methods to the analyst and allowing them to rank the performance of each for the purposes of detecting pbo is an exciting piece of future work we will look to implement in quantstrat in due course.</li>
<li>computePSR - a helper function within evalPerf() for computing the psrStat and psr.</li>
</ul>
<p>We have kept the names of the helper functions identical to those used in the python program.</p>
<p>When the dataMine() function is called, we print the SR along with other strategy charateristics to the console for the first strategy and every subsequent strategy which improves on the prior SR. The last iteration to print once the function has completed, will be the iteration which generated the max Sharpe ratio. Each line prints 8 different details, which are:</p>
<ol style="list-style-type: decimal">
<li>iteration number,</li>
<li>business day in month used for entry day,</li>
<li>holding period,</li>
<li>stop loss,</li>
<li>side (-1 for sell, 1 for buy),</li>
<li>Sharpe ratio,</li>
<li>Frequency (see calc in evalPerf function),</li>
<li>psrStat or probabilistic Sharpe ratio statistic</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dataMine &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">nDays=</span><span class="dv">0</span>, <span class="dt">factor=</span><span class="dv">0</span>){
  <span class="co"># 1) Input parameters --- to be changed by the user</span>
  holdingPeriod &lt;-<span class="st"> </span><span class="dv">20</span>
  sigma &lt;-<span class="st"> </span><span class="dv">1</span>
  stopLoss &lt;-<span class="st"> </span><span class="dv">10</span>
  length &lt;-<span class="st"> </span><span class="dv">1000</span>
  <span class="co"># 2) Prepare series</span>
  date &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;2000-01-01&quot;</span>) <span class="co"># original python program uses 01/01/2000 start date</span>
  dates &lt;-<span class="st"> </span><span class="kw">list</span>()
  
  <span class="cf">while</span>(<span class="kw">length</span>(dates) <span class="op">&lt;</span><span class="st"> </span>length){
    <span class="cf">if</span>(<span class="kw">as.POSIXlt</span>(date)<span class="op">$</span>wday <span class="op">!=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw">as.POSIXlt</span>(date)<span class="op">$</span>wday <span class="op">!=</span><span class="st"> </span><span class="dv">6</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw">length</span>(dates) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      dates &lt;-<span class="st"> </span>date
    } <span class="cf">else</span> <span class="cf">if</span>(<span class="kw">as.POSIXlt</span>(date)<span class="op">$</span>wday <span class="op">!=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw">as.POSIXlt</span>(date)<span class="op">$</span>wday <span class="op">!=</span><span class="st"> </span><span class="dv">6</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw">length</span>(dates) <span class="op">!=</span><span class="st"> </span><span class="dv">0</span>){
      dates &lt;-<span class="st"> </span><span class="kw">append</span>(dates, date)
    }
    date &lt;-<span class="st"> </span><span class="kw">as.Date</span>(date) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  
  series &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> length, <span class="dt">ncol =</span> <span class="dv">1</span>)
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(series)){
    series[i] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dt">mean =</span> <span class="dv">0</span>, <span class="dt">sd =</span> sigma)
    pDay &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">paste</span>(<span class="kw">format</span>(<span class="kw">as.Date</span>(dates[i], <span class="dt">format=</span><span class="st">&quot;%d/%m/%Y&quot;</span>),<span class="st">&quot;%Y&quot;</span>),
                          <span class="kw">format</span>(<span class="kw">as.Date</span>(dates[i], <span class="dt">format=</span><span class="st">&quot;%d/%m/%Y&quot;</span>),<span class="st">&quot;%m&quot;</span>),
                          <span class="dv">1</span>,
                          <span class="dt">sep =</span> <span class="st">&quot;-&quot;</span>)
    )
    <span class="cf">if</span>(<span class="kw">numBusinessDays</span>(pDay, dates[i]) <span class="op">&lt;=</span><span class="st"> </span>nDays){
      series[i] &lt;-<span class="st"> </span>series[i] <span class="op">+</span><span class="st"> </span>sigma <span class="op">*</span><span class="st"> </span>factor
    }
  }
  series &lt;-<span class="st"> </span><span class="kw">cumsum</span>(series)
  <span class="co"># 3) Optimize</span>
  <span class="co"># get the daily index in each month for each date in the series,</span>
  <span class="co"># so the 2nd BD in Jan 2000 is 03/01/2000 and in Feb 2000 is</span>
  <span class="co"># 02/02/2000. refDates[[2]] will be a list of elements with these dates.</span>
  refDates &lt;-<span class="st"> </span><span class="kw">getRefDates_MonthBusinessDate</span>(dates) 
  psr &lt;-<span class="st"> </span>sr &lt;-<span class="st"> </span>trades &lt;-<span class="st"> </span>sl &lt;-<span class="st"> </span>freq &lt;-<span class="st"> </span>pDay &lt;-<span class="st"> </span>pnl &lt;-<span class="st"> </span><span class="ot">NULL</span>
  count &lt;-<span class="st"> </span><span class="dv">0</span>
  <span class="co"># start of main loop - we loop over each date in the refDates list</span>
  sr &lt;-<span class="st"> </span><span class="ot">NULL</span>
  <span class="cf">for</span>(pDay <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(refDates)){
    refDates_<span class="dv">0</span> &lt;-<span class="st"> </span>refDates[[pDay]]
    <span class="cf">if</span>(<span class="kw">length</span>(refDates_<span class="dv">0</span>) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      <span class="cf">next</span>
    }
    <span class="co"># 4) Get trades</span>
    iterdf &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">z=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">y=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">10</span><span class="op">:</span><span class="dv">0</span>), <span class="dt">x=</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">20</span>))
    iterdf &lt;-<span class="st"> </span>iterdf[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>)]
    <span class="cf">for</span>(prod <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(iterdf)){
      count =<span class="st"> </span>count <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
      trades_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="kw">getTrades</span>(series, dates, refDates_<span class="dv">0</span>, iterdf[prod,<span class="dv">1</span>], iterdf[prod,<span class="dv">2</span>], iterdf[prod,<span class="dv">3</span>])
      dates_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="ot">NULL</span>
      pnl_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="ot">NULL</span>
      <span class="cf">if</span>(<span class="kw">length</span>(trades_<span class="dv">0</span>) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) { <span class="cf">next</span> }
      <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(trades_<span class="dv">0</span>)) { dates_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="kw">append</span>(dates_<span class="dv">0</span>, trades_<span class="dv">0</span>[[j]][<span class="dv">1</span>]) }
      <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(trades_<span class="dv">0</span>)) { pnl_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="kw">append</span>(pnl_<span class="dv">0</span>, <span class="kw">as.numeric</span>(trades_<span class="dv">0</span>[[j]][<span class="dv">4</span>])) }
      <span class="co"># 5) Eval performance</span>
      <span class="cf">if</span>(<span class="kw">length</span>(pnl_<span class="dv">0</span>) <span class="op">&gt;</span><span class="st"> </span><span class="dv">2</span>){
        <span class="co"># 6) Reconcile PnL</span>
        pnl &lt;-<span class="st"> </span><span class="kw">attachTimeSeries</span>(pnl, pnl_<span class="dv">0</span>, dates_<span class="dv">0</span>, count)
        <span class="co"># 7) Evaluate</span>
        eval_list &lt;-<span class="st"> </span><span class="kw">list</span>()
        eval_list &lt;-<span class="st"> </span><span class="kw">evalPerf</span>(pnl_<span class="dv">0</span>, dates[<span class="dv">1</span>], dates[<span class="kw">length</span>(dates)])
        <span class="kw">names</span>(eval_list) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;sr_0&quot;</span>,<span class="st">&quot;psr_0&quot;</span>,<span class="st">&quot;freq_0&quot;</span>)
        <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(pnl_<span class="dv">0</span>)){
          pnl_<span class="dv">0</span>[j] &lt;-<span class="st"> </span>pnl_<span class="dv">0</span>[j] <span class="op">+</span><span class="st"> </span>pnl_<span class="dv">0</span>[j <span class="op">-</span><span class="st"> </span><span class="dv">1</span>]
        }
        <span class="cf">if</span>(<span class="kw">is.null</span>(sr)){
          sr &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># give sr a numeric value</span>
        }
        <span class="cf">if</span>(eval_list[<span class="st">&quot;sr_0&quot;</span>] <span class="op">&gt;</span><span class="st"> </span>sr){ <span class="co"># if sr == None or sr_ &gt; sr:</span>
          psr &lt;-<span class="st"> </span>eval_list[<span class="st">&quot;psr_0&quot;</span>]
          sr &lt;-<span class="st"> </span>eval_list[<span class="st">&quot;sr_0&quot;</span>]
          trades_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="kw">unlist</span>(trades_<span class="dv">0</span>), <span class="dt">nrow=</span><span class="kw">length</span>(trades_<span class="dv">0</span>), <span class="dt">byrow=</span>T),<span class="dt">stringsAsFactors=</span><span class="ot">FALSE</span>)
          trades_df[,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">as.Date</span>(trades_df[,<span class="dv">1</span>])
          <span class="kw">colnames</span>(trades_df) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;txndate&quot;</span>,<span class="st">&quot;num&quot;</span>,<span class="st">&quot;side&quot;</span>,<span class="st">&quot;daypl&quot;</span>)
          freq &lt;-<span class="st"> </span>eval_list[<span class="st">&quot;freq_0&quot;</span>]
          pDay &lt;-<span class="st"> </span>pDay <span class="co"># freq, pDay, prod = freq_, pDay_, prod_</span>
          constraints &lt;-<span class="st"> </span><span class="kw">c</span>(iterdf[prod,<span class="dv">1</span>],iterdf[prod,<span class="dv">2</span>],iterdf[prod,<span class="dv">3</span>])
          <span class="kw">cat</span>(count, pDay, constraints, <span class="kw">round</span>(sr,<span class="dv">2</span>), <span class="kw">round</span>(freq,<span class="dv">2</span>), <span class="kw">round</span>(psr,<span class="dv">2</span>), <span class="dt">fill =</span> <span class="ot">TRUE</span>, <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>)
        }
      }
    }
  }
  ret &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">Total_Iterations =</span> count,
              <span class="dt">PL =</span> pnl,
              <span class="dt">PSR =</span> psr,
              <span class="dt">SR =</span> sr,
              <span class="dt">trades =</span> trades_df,
              <span class="dt">Freq =</span> freq,
              <span class="dt">Business_Day =</span> pDay,
              <span class="dt">HP_SL_Side =</span> constraints, <span class="co"># HP = Holding Period, SL = Stop Loss, Side = Side</span>
              <span class="dt">Dates =</span> dates,
              <span class="dt">cumsum_Series =</span> series) <span class="co"># series is a cumsum of the original return series</span>
  
  <span class="kw">class</span>(ret) &lt;-<span class="st"> &quot;dataMine&quot;</span>
  ret
}

<span class="co"># ----------------------------------------------------------------------------------------</span>
evalPerf &lt;-<span class="st"> </span><span class="cf">function</span>(pnl, date0, date1, <span class="dt">sr_ref=</span><span class="dv">0</span>){
  freq &lt;-<span class="st"> </span>(<span class="kw">length</span>(pnl) <span class="op">/</span><span class="st"> </span><span class="kw">as.numeric</span>((<span class="kw">difftime</span>(date1, date0) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)) <span class="op">*</span><span class="st"> </span><span class="fl">365.25</span>)
  m1 =<span class="st"> </span><span class="kw">mean</span>(pnl)
  m2 =<span class="st"> </span><span class="kw">sd</span>(pnl)
  m3 =<span class="st"> </span><span class="kw">skewness</span>(pnl)
  m4 =<span class="st"> </span><span class="kw">kurtosis</span>(pnl, <span class="dt">methods =</span> <span class="st">&quot;fisher&quot;</span>) <span class="co"># fisher=False in original, but unsure what alternative to use</span>
  sr =<span class="st"> </span>m1 <span class="op">/</span><span class="st"> </span>m2 <span class="op">*</span><span class="st"> </span>freq <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span>
  psr =<span class="st"> </span><span class="kw">computePSR</span>(<span class="kw">c</span>(m1, m2, m3, m4), <span class="kw">length</span>(pnl), <span class="dt">sr_ref=</span>sr_ref <span class="op">/</span><span class="st"> </span>freq <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span>, <span class="dt">moments=</span><span class="dv">4</span>)[<span class="dv">1</span>]
  <span class="kw">return</span>(<span class="kw">c</span>(sr, psr, freq))
}

<span class="co"># ----------------------------------------------------------------------------------------</span>
computePSR &lt;-<span class="st"> </span><span class="cf">function</span>(stats, obs, <span class="dt">sr_ref=</span><span class="dv">0</span>, <span class="dt">moments=</span><span class="dv">4</span>){
  <span class="co"># Compute PSR</span>
  stats_<span class="dv">0</span> =<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">3</span>)
  stats_<span class="dv">0</span> =<span class="st"> </span>stats[<span class="dv">1</span><span class="op">:</span>moments]
  sr =<span class="st"> </span>stats_<span class="dv">0</span>[<span class="dv">1</span>] <span class="op">/</span><span class="st"> </span>stats_<span class="dv">0</span>[<span class="dv">2</span>]
  psrStat =<span class="st"> </span>(sr <span class="op">-</span><span class="st"> </span>sr_ref) <span class="op">*</span><span class="st"> </span>(obs <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>sr <span class="op">*</span><span class="st"> </span>stats_<span class="dv">0</span>[<span class="dv">3</span>] <span class="op">+</span><span class="st"> </span>sr <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(stats_<span class="dv">0</span>[<span class="dv">4</span>] <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span><span class="dv">4</span>.) <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span>
  psr =<span class="st"> </span><span class="kw">pnorm</span>((sr <span class="op">-</span><span class="st"> </span>sr_ref) <span class="op">*</span><span class="st"> </span>(obs <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>sr <span class="op">*</span><span class="st"> </span>stats_<span class="dv">0</span>[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span>sr <span class="op">**</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(stats_<span class="dv">0</span>[<span class="dv">3</span>] <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span><span class="dv">4</span>.) <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span>)
  <span class="kw">return</span>(<span class="kw">c</span>(psrStat, psr))
}

<span class="co"># ----------------------------------------------------------------------------------------</span>
attachTimeSeries &lt;-<span class="st"> </span><span class="cf">function</span>(series, series_<span class="dv">0</span>, <span class="dt">index=</span>None, <span class="dt">label=</span><span class="st">''</span>, <span class="dt">how=</span><span class="st">'outer'</span>){
  <span class="cf">if</span>(<span class="kw">is.null</span>(series)){
    series &lt;-<span class="st"> </span><span class="kw">xts</span>(series_<span class="dv">0</span>, <span class="kw">as.Date</span>(<span class="kw">unlist</span>(index)))
  } <span class="cf">else</span> {
    series_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="kw">xts</span>(series_<span class="dv">0</span>, <span class="kw">as.Date</span>(<span class="kw">unlist</span>(index)))
    series &lt;-<span class="st"> </span><span class="kw">merge</span>(series, series_<span class="dv">0</span>)
  }
  <span class="kw">return</span>(series)
}


<span class="co"># ----------------------------------------------------------------------------------------</span>
getTrades &lt;-<span class="st"> </span><span class="cf">function</span>(series, dates, refDates, exit, stopLoss, side){
  <span class="co"># Get trades</span>
  trades &lt;-<span class="st"> </span><span class="kw">list</span>()
  pnl &lt;-<span class="st"> </span>position_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="dv">0</span>
  j &lt;-<span class="st"> </span><span class="dv">1</span>
  num &lt;-<span class="st"> </span><span class="ot">NULL</span>
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(dates)){
    <span class="co"># Find next roll and how many trading dates to it</span>
    <span class="cf">if</span>(dates[i] <span class="op">&gt;=</span><span class="st"> </span>refDates[j]){
      <span class="cf">if</span>(dates[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">&lt;</span><span class="st"> </span>refDates[j]){ num &lt;-<span class="st"> </span>pnl &lt;-<span class="st"> </span><span class="dv">0</span> }
      <span class="cf">if</span>(j <span class="op">&lt;</span><span class="st"> </span><span class="kw">length</span>(refDates) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>){
        <span class="cf">while</span>(dates[i] <span class="op">&gt;</span><span class="st"> </span>refDates[j]) { j =<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="dv">1</span> }
      }
    }
    <span class="cf">if</span>(<span class="kw">is.null</span>(num)){ <span class="cf">next</span> }
    <span class="co"># Trading rule</span>
    position &lt;-<span class="st"> </span><span class="dv">0</span>
    <span class="cf">if</span>(num <span class="op">&lt;</span><span class="st"> </span>exit <span class="op">&amp;</span><span class="st"> </span>pnl <span class="op">&gt;</span><span class="st"> </span>stopLoss){ position &lt;-<span class="st"> </span>side }
    <span class="cf">if</span>(position <span class="op">!=</span><span class="st"> </span><span class="dv">0</span> <span class="op">|</span><span class="st"> </span>position_<span class="dv">0</span> <span class="op">!=</span><span class="st"> </span><span class="dv">0</span>) {
      trades &lt;-<span class="st"> </span><span class="kw">append</span>(trades, <span class="kw">list</span>(<span class="kw">list</span>(<span class="kw">as.Date</span>(dates[i]), <span class="kw">as.numeric</span>(num), 
                                         <span class="kw">as.numeric</span>(position), 
                                         <span class="kw">as.numeric</span>(position_<span class="dv">0</span> <span class="op">*</span><span class="st"> </span>(series[i] <span class="op">-</span><span class="st"> </span>series[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>])))))
      pnl &lt;-<span class="st"> </span>pnl <span class="op">+</span><span class="st"> </span><span class="kw">as.numeric</span>(trades[[<span class="kw">length</span>(trades)]][<span class="dv">4</span>])
      position_<span class="dv">0</span> &lt;-<span class="st"> </span>position
    }
    num &lt;-<span class="st"> </span>num <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  <span class="kw">return</span>(trades)
}

<span class="co"># ----------------------------------------------------------------------------------------</span>
getRefDates_MonthBusinessDate &lt;-<span class="st"> </span><span class="cf">function</span>(dates){
  refDates &lt;-<span class="st"> </span><span class="kw">list</span>() <span class="co"># python dict in de Prado program</span>
  pDay &lt;-<span class="st"> </span><span class="kw">list</span>()
  first &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">paste</span>(<span class="kw">format</span>(<span class="kw">as.Date</span>(dates[<span class="dv">1</span>], <span class="dt">format=</span><span class="st">&quot;%d/%m/%Y&quot;</span>),<span class="st">&quot;%Y&quot;</span>),
                         <span class="kw">format</span>(<span class="kw">as.Date</span>(dates[<span class="dv">1</span>], <span class="dt">format=</span><span class="st">&quot;%d/%m/%Y&quot;</span>),<span class="st">&quot;%m&quot;</span>),
                         <span class="dv">1</span>,
                         <span class="dt">sep =</span> <span class="st">&quot;-&quot;</span>)
  )
  m &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">format</span>(dates[<span class="dv">1</span>],<span class="st">&quot;%m&quot;</span>))
  d &lt;-<span class="st"> </span><span class="kw">numBusinessDays</span>(first, dates[<span class="dv">1</span>]) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  <span class="co"># For all dates, get the day (int)...will be all business days, and assign to pDay</span>
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(dates)){
    <span class="cf">if</span>(m <span class="op">!=</span><span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">format</span>(dates[i],<span class="st">&quot;%m&quot;</span>))){ 
      m &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">format</span>(<span class="kw">as.Date</span>(dates[i], <span class="dt">format=</span><span class="st">&quot;%d/%m/%Y&quot;</span>),<span class="st">&quot;%m&quot;</span>))
      d &lt;-<span class="st"> </span><span class="dv">1</span>
    }
    pDay &lt;-<span class="st"> </span><span class="kw">append</span>(pDay, d)
    d &lt;-<span class="st"> </span>d <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">30</span>){ <span class="co"># python &quot;range(1,30)&quot;</span>
    lst &lt;-<span class="st"> </span><span class="kw">list</span>()
    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(dates)){
      <span class="cf">if</span>(pDay[i] <span class="op">==</span><span class="st"> </span>j){
        lst &lt;-<span class="st"> </span><span class="kw">append</span>(lst, dates[i])
      }
    }
    refDates[[j]] =<span class="st"> </span>lst
  }
  <span class="kw">return</span>(refDates)
}

<span class="co"># ----------------------------------------------------------------------------------------</span>
numBusinessDays &lt;-<span class="st"> </span><span class="cf">function</span>(date0, date1){
  m &lt;-<span class="st"> </span><span class="dv">1</span>
  date_<span class="dv">0</span> &lt;-<span class="st"> </span>date0
  <span class="cf">while</span>(<span class="ot">TRUE</span>){
    date_<span class="dv">0</span> &lt;-<span class="st"> </span><span class="kw">as.Date</span>(date_<span class="dv">0</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    <span class="cf">if</span>(date_<span class="dv">0</span> <span class="op">&gt;=</span><span class="st"> </span>date1){ <span class="cf">break</span> }
    <span class="cf">if</span>(<span class="kw">as.POSIXlt</span>(date_<span class="dv">0</span>)<span class="op">$</span>wday <span class="op">!=</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span><span class="kw">as.POSIXlt</span>(date_<span class="dv">0</span>)<span class="op">$</span>wday <span class="op">!=</span><span class="st"> </span><span class="dv">6</span>){
      m &lt;-<span class="st"> </span>m <span class="op">+</span><span class="st"> </span><span class="dv">1</span> 
    }
  }
  <span class="kw">return</span>(m)
}</code></pre></div>
<p>We will implement the dataMine() function twice, as in the paper, once for a purely random series and again for a seasonally adjusted series. In the first case we leave the default values for parameters ‘nDays’ and ‘factor’, which are zero. In the second run, we use ‘nDays’ = 5 and ‘factor’ = 0.25.</p>
<div id="random" class="section level3">
<h3>Random</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># First build our Sharpe function - the performance metric used in the paper for determining PBO</span>
<span class="co"># which gets passed to pbo() as the performance metric used</span>
sharpe &lt;-<span class="st"> </span><span class="cf">function</span>(x,<span class="dt">rf=</span><span class="fl">0.03</span><span class="op">/</span><span class="dv">252</span>) {
  sr &lt;-<span class="st"> </span><span class="kw">apply</span>(x,<span class="dv">2</span>,<span class="cf">function</span>(col) {
    er =<span class="st"> </span>col <span class="op">-</span><span class="st"> </span>rf
    <span class="kw">return</span>(<span class="kw">mean</span>(er)<span class="op">/</span><span class="kw">sd</span>(er))
  })
  <span class="kw">return</span>(sr)
}

<span class="co"># Run dataMine() for a random series</span>
<span class="kw">set.seed</span>(<span class="dv">777</span>)
t1 &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
dm_random &lt;-<span class="st"> </span><span class="kw">dataMine</span>(<span class="dt">nDays =</span> <span class="dv">0</span>, <span class="dt">factor =</span> <span class="dv">0</span>)
<span class="co">#&gt; 1,1,1,-10,-1,0.77,22.99,1.52</span>
<span class="co">#&gt; 68,1,4,-10,1,0.93,57.48,1.85</span>
<span class="co">#&gt; 84,1,4,-2,1,0.93,56.43,1.86</span>
<span class="co">#&gt; 464,2,2,-10,1,1.29,34.49,2.7</span>
<span class="co">#&gt; 486,2,3,-10,1,1.46,45.98,2.97</span>
<span class="co">#&gt; 502,2,3,-2,1,1.54,45.72,3.16</span>
<span class="co">#&gt; 504,2,3,-1,1,1.55,44.94,3.19</span>
t2 &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
timediff &lt;-<span class="st"> </span><span class="kw">difftime</span>(t2,t1)
timediff
<span class="co">#&gt; Time difference of 1.055647 hours</span>

<span class="co"># blotter:::pbo</span>
dm_random<span class="op">$</span>PL[<span class="op">!</span><span class="kw">is.finite</span>(dm_random<span class="op">$</span>PL)] &lt;-<span class="st"> </span><span class="dv">0</span>
pbo_random  &lt;-<span class="st"> </span>blotter<span class="op">:::</span><span class="kw">pbo</span>(dm_random<span class="op">$</span>PL, <span class="dt">f=</span>sharpe)
<span class="kw">summary</span>(pbo_random)
<span class="co">#&gt; Performance function sharpe with threshold 0</span>
<span class="co">#&gt;    p_bo   slope    ar^2  p_loss </span>
<span class="co">#&gt; 0.50000 0.11922 0.08100 0.48600</span>
<span class="co"># histogram(random_series,type=&quot;density&quot;)</span>
<span class="co"># xyplot(random_series,plotType=&quot;degradation&quot;)</span></code></pre></div>
</div>
<div id="seasonal" class="section level3">
<h3>Seasonal</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># First build our Sharpe function - the performance metric used in the paper for determining PBO</span>
<span class="co"># which gets passed to pbo() as the performance metric used</span>
sharpe &lt;-<span class="st"> </span><span class="cf">function</span>(x,<span class="dt">rf=</span><span class="fl">0.03</span><span class="op">/</span><span class="dv">252</span>) {
  sr &lt;-<span class="st"> </span><span class="kw">apply</span>(x,<span class="dv">2</span>,<span class="cf">function</span>(col) {
    er =<span class="st"> </span>col <span class="op">-</span><span class="st"> </span>rf
    <span class="kw">return</span>(<span class="kw">mean</span>(er)<span class="op">/</span><span class="kw">sd</span>(er))
  })
  <span class="kw">return</span>(sr)
}
<span class="co"># Run dataMine() for a seasonal series</span>
t3 &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw">set.seed</span>(<span class="dv">777</span>)
dm_season &lt;-<span class="st"> </span><span class="kw">dataMine</span>(<span class="dt">nDays =</span> <span class="dv">5</span>, <span class="dt">factor =</span> <span class="fl">0.25</span>)
<span class="co">#&gt; 2,1,1,-10,1,0.19,22.99,0.37</span>
<span class="co">#&gt; 24,1,2,-10,1,1.37,34.49,2.85</span>
<span class="co">#&gt; 46,1,3,-10,1,2.13,45.98,4.65</span>
<span class="co">#&gt; 68,1,4,-10,1,2.63,57.48,5.64</span>
<span class="co">#&gt; 486,2,3,-10,1,2.87,45.98,6.43</span>
<span class="co">#&gt; 504,2,3,-1,1,2.9,45.46,6.55</span>
t4 &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw">print</span>(t4<span class="op">-</span>t3)
<span class="co">#&gt; Time difference of 23.89026 mins</span>
dm_season<span class="op">$</span>PL[<span class="op">!</span><span class="kw">is.finite</span>(dm_season<span class="op">$</span>PL)] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># Replace NAs with zeros</span>
pbo_seasonal  &lt;-<span class="st"> </span>blotter<span class="op">:::</span><span class="kw">pbo</span>(dm_season<span class="op">$</span>PL, <span class="dt">f=</span>sharpe)
<span class="kw">summary</span>(pbo_seasonal)
<span class="co">#&gt; Performance function sharpe with threshold 0</span>
<span class="co">#&gt;    p_bo   slope    ar^2  p_loss </span>
<span class="co">#&gt; 0.00000 0.19634 0.05000 0.00000</span>
<span class="co"># histogram(season_series,type=&quot;density&quot;)</span>
<span class="co"># xyplot(season_series,plotType=&quot;degradation&quot;)</span></code></pre></div>
<p>The PBO results from both the random and seasonally adjusted series should be very similar to what is reported in the paper. Bailey et al. get an optimal SR of 1.27 from all their trials for the random series and a PBO of 55%. For the seasonal series they report an optimal SR of 1.54 and a PBO of only 13%. When we set the seed for both runs of dataMine() to be equivalent and equating to 777 (jackpot) for the purposes of comparison and replication, we get an optimal SR of 1.55 for the random series and a PBO of 50%. For the seasonal series we get an optimal SR of 2.9 and a PBO of 0%. The PBO scores using the results from our dataMine() program reflect similar results compared with Bailey et al. (55% and 13% respectively). The optimal iteration occurs at number 504 for both series’, when the random seed is set to 777.</p>
</div>
<div id="future-work" class="section level3">
<h3>Future work</h3>
<ul>
<li>Adding different performance metrics as methods to a blotter:::pbo</li>
<li>Adding a function for comparing overfit statistics for the different performance metrics. Presumably using the Sharpe ratio as your metric will give diferent results compared to using max drawdown, or Sortino Ratio etc. Can this tell us anything about the relevance and/or applicability of the different performance metrics?</li>
<li>Apply output from txnsim to pbo(), since txnsim() attempts to evaluate overfitting in the context of randomised versions of the original strategy whilst honouring the outward resemblance of the original strategy.</li>
<li>Optimise dataMine() with vectorization.</li>
</ul>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
